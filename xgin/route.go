package xgin

import (
	"fmt"
	"github.com/Aoi-hosizora/ahlib/xnumber"
	"github.com/Aoi-hosizora/ahlib/xreflect"
	"github.com/gin-gonic/gin"
	"net/http"
	"reflect"
	"runtime"
	"strings"
)

// AppRoute represents a group of methods (method is a group of routes) with gin.Engine and gin.IRouter, as a replacement of
// gin's trie router model.
//
// Note:
//
// 1. gin supports:
// 	route.GET(":a", fn)
// 	route.GET(":a/:b", fn)
//
// 2. gin does not support:
// 	route.GET("a", fn)
// 	route.GET(":a/:b", fn) // panic here
//
// 3. AppRoute.Register implements this:
// 	ap.GET("a", fn)
// 	ap.GET(":a", fn)
// 	ap.GET(":a/b", fn)
// 	ap.GET(":a/:b", fn)
//
// Also see https://github.com/gin-gonic/gin/blob/master/tree.go.
type AppRoute struct {
	engine *gin.Engine
	router gin.IRouter
	groups [][]*routeConfig // groups: []method, method: []*routeConfig.

	noRoute  gin.HandlersChain // for 404
	noMethod gin.HandlersChain // for 405
}

// NewAppRoute creates an empty AppRoute.
func NewAppRoute(engine *gin.Engine, router gin.IRouter) *AppRoute {
	noRoute := xreflect.GetUnexportedField(reflect.ValueOf(engine).Elem().FieldByName("noRoute")).(gin.HandlersChain)
	noMethod := xreflect.GetUnexportedField(reflect.ValueOf(engine).Elem().FieldByName("noMethod")).(gin.HandlersChain)
	if noRoute == nil {
		noRoute = []gin.HandlerFunc{func(c *gin.Context) {
			c.String(404, "404 page not found")
		}}
	}
	if noMethod == nil {
		noMethod = []gin.HandlerFunc{func(c *gin.Context) {
			c.String(405, "405 method not allowed")
		}}
	}

	return &AppRoute{
		engine: engine, router: router, groups: [][]*routeConfig{},
		noRoute: noRoute, noMethod: noMethod,
	}
}

// routeConfig represents a route config used in AppRoute, including relativePath and handlers.
type routeConfig struct {
	method       string
	relativePath string
	handlers     []gin.HandlerFunc
	parameters   []string // generated by relative path
}

const (
	panicNoHandler             = "xgin: a route must have at least one handler"
	panicUseUnderlineParameter = "xgin: use parameter started with underline in gin.IRouter"
)

// newRouteConfig creates an instance of routeConfig, panics if handlers is empty.
func newRouteConfig(method string, relativePath string, handlers ...gin.HandlerFunc) *routeConfig {
	if len(handlers) == 0 {
		panic(panicNoHandler)
	}
	relativePath = strings.Trim(relativePath, "/")
	parameters := make([]string, 0)
	if relativePath != "" {
		parameters = strings.Split(relativePath, "/")
	}
	return &routeConfig{method: method, relativePath: relativePath, parameters: parameters, handlers: handlers}
}

// GET registers a new list of handlers to given path and uses get method.
func (a *AppRoute) GET(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodGet, relativePath, handlers)
}

// POST registers a new list of handlers to given path and uses post method.
func (a *AppRoute) POST(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodPost, relativePath, handlers)
}

// DELETE registers a new list of handlers to given path and uses delete method.
func (a *AppRoute) DELETE(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodDelete, relativePath, handlers)
}

// PATCH registers a new list of handlers to given path and uses patch method.
func (a *AppRoute) PATCH(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodPatch, relativePath, handlers)
}

// PUT registers a new list of handlers to given path and uses put method.
func (a *AppRoute) PUT(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodPut, relativePath, handlers)
}

// OPTIONS registers a new list of handlers to given path and uses options method.
func (a *AppRoute) OPTIONS(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodOptions, relativePath, handlers)
}

// HEAD registers a new list of handlers to given path and uses head method.
func (a *AppRoute) HEAD(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodHead, relativePath, handlers)
}

// Any registers a new list of handlers to given path and uses all the supported http methods: get, post, delete, patch, put, options, head.
func (a *AppRoute) Any(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodGet, relativePath, handlers)
	a.addToGroups(http.MethodPost, relativePath, handlers)
	a.addToGroups(http.MethodDelete, relativePath, handlers)
	a.addToGroups(http.MethodPatch, relativePath, handlers)
	a.addToGroups(http.MethodPut, relativePath, handlers)
	a.addToGroups(http.MethodOptions, relativePath, handlers)
	a.addToGroups(http.MethodHead, relativePath, handlers)
}

// addToGroups is used to add handlers to AppRoute.groups.
func (a *AppRoute) addToGroups(method string, relativePath string, handlers []gin.HandlerFunc) {
	basePath := xreflect.GetUnexportedField(reflect.ValueOf(a.router.(*gin.RouterGroup)).Elem().FieldByName("basePath")).(string)
	for _, parameter := range strings.Split(basePath, "/") {
		if strings.HasPrefix(parameter, "_") { // check _xxx parameter first
			panic(panicUseUnderlineParameter)
		}
	}

	r := newRouteConfig(method, relativePath, handlers...)
	for idx := range a.groups {
		routes := a.groups[idx]
		if routes[0].method == method {
			a.groups[idx] = append(routes, r)
			return
		}
	}
	a.groups = append(a.groups, []*routeConfig{r})
}

// Register registers all registered routes to gin.IRouter using gin.Engine's config.
func (a *AppRoute) Register() {
	for idx := range a.groups {
		routes := a.groups[idx] // same method's routes
		method := routes[0].method
		coreRegister(a, method, routes) // do register in all routes in one method
	}
}

// DebugPrintAppRouteFunc is a logger function (do log after each gin's each handler's log) for the same layer's handlers,
// using given method, layer routes and layer path. You can rewrite this function.
var DebugPrintAppRouteFunc = func(method string, layerRoutes []*routeConfig, layerPath string) {
	for i, route := range layerRoutes { // same layer's routes
		pre := "├─"
		if i == len(layerRoutes)-1 {
			pre = "└─"
		}

		path := route.relativePath
		funcname := runtime.FuncForPC(reflect.ValueOf(route.handlers[0]).Pointer()).Name()
		fmt.Printf("[XGIN]   %2s %-6s ~/%-23s --> %s (--> ~/%s)\n", pre, method, path, funcname, layerPath)
	}
}

// ====
// core
// ====

// coreRegister is the core implementation of AppRoute.Register, with given method and same method routes.
func coreRegister(ar *AppRoute, method string, routes []*routeConfig) {
	// get max layer count
	maxLayerCount := 0
	for _, route := range routes {
		if len(route.parameters) > maxLayerCount {
			maxLayerCount = len(route.parameters)
		}
	}

	// rearrange routes by layer count
	layersRoutes := make([][]*routeConfig, maxLayerCount+1) // layer count -> routes
	for idx := range routes {
		methodRoute := routes[idx]
		layerCount := len(methodRoute.parameters)
		layersRoutes[layerCount] = append(layersRoutes[layerCount], methodRoute)
	}

	// core: build handler to handle !!!
	for layer := range layersRoutes {
		layerRoutes := layersRoutes[layer] // same layer's routes

		// empty relative path
		if layer == 0 {
			for _, route := range layerRoutes {
				ar.router.Handle(method, "", route.handlers...) // handle first
			}
			continue
		}

		// build fake path string (:_1/:_2/...)
		layerNumericParams := make([]string, layer) // :_1, :_2, ...
		for i := 1; i <= layer; i++ {
			layerNumericParams[i-1] = ":_" + xnumber.Itoa(i)
		}
		layerFakePath := strings.Join(layerNumericParams, "/")

		// get final handler and register to gin.IRouter
		finalHandler := finalAppRouteHandler(ar, method, layerRoutes, layerFakePath)
		ar.router.Handle(method, layerFakePath, finalHandler)

		// print log
		if gin.Mode() == gin.DebugMode && DebugPrintAppRouteFunc != nil {
			DebugPrintAppRouteFunc(method, layerRoutes, layerFakePath)
		}
	}
}

// finalAppRouteHandler builds and returns a new gin.HandlerFunc for AppRoute to register to gin.IRouter using given layer routes.
func finalAppRouteHandler(ar *AppRoute, method string, layerRoutes []*routeConfig, layerFakePath string) gin.HandlerFunc {
	// will be invoked at runtime
	return func(c *gin.Context) {
		// find accepted handlers ==> O(#same_layer_routers * #later_parameters)
		handlers, ok := findRouteHandlers(c, layerRoutes, layerFakePath, true)

		// handlers not found, use 404 or 405 (note that 405 may be invoked by gin's HandleMethodNotAllowed)
		if !ok {
			handlers = ar.noRoute // use 404 noRoute
			if ar.engine.HandleMethodNotAllowed {
				for _, methodRoutes := range ar.groups {
					if method == methodRoutes[0].method {
						continue
					}
					if _, ok := findRouteHandlers(c, methodRoutes, layerFakePath, false); ok {
						handlers = ar.noMethod // use 405 noMethod
						break
					}
				}
			}
		}

		// run handlers
		for _, handler := range handlers {
			if handler != nil && !c.IsAborted() {
				handler(c)
			}
		}
	}
}

// findRouteHandlers finds a acceptable []gin.HandlerFunc from routes by given gin.Context (with its parameters) and switcher for changing gin.Context's parameter.
func findRouteHandlers(c *gin.Context, routes []*routeConfig, layerFakePath string, changeContext bool) ([]gin.HandlerFunc, bool) {
	for _, route := range routes {
		// filter different length of parameters
		actualParamsLength := 0 // start with _'s parameter's length
		for _, param := range c.Params {
			if strings.HasPrefix(param.Key, "_") {
				actualParamsLength++
			}
		}
		if actualParamsLength != len(route.parameters) {
			continue
		}

		// check if accept the current route
		accept := true
		for idx, parameter := range route.parameters {
			// parameters: aaa, :bbb, ccc
			// fullPath: /xxx/:_1/:_2/:_3
			if strings.HasPrefix(parameter, ":") { // belongs to `:` parameter, can be converted directly
				continue
			}
			layerKey := "_" + xnumber.Itoa(idx+1)
			if parameter != c.Param(layerKey) { // compare layerKey's c.Param and route.parameter
				accept = false // the actual parameter does not equals to given route's parameter
				break
			}
		}

		// change context and return if accept
		if accept {
			if changeContext {
				// set new c.Params
				for idx, parameter := range route.parameters {
					if strings.HasPrefix(parameter, ":") { // belongs to `:` parameter
						key := parameter[1:]                  // :bbb ===> :_2
						layerKey := "_" + xnumber.Itoa(idx+1) // :_2
						value := c.Param(layerKey)
						c.Params = append(c.Params, gin.Param{Key: key, Value: value})
					}
				}

				// set new c.fullPath
				fullPath := strings.TrimSuffix(c.FullPath(), "/")
				fullPath = strings.TrimSuffix(strings.TrimSuffix(fullPath, layerFakePath), "/")
				fullPath = fmt.Sprintf("%s/%s", fullPath, route.relativePath)
				xreflect.SetUnexportedField(reflect.ValueOf(c).Elem().FieldByName("fullPath"), fullPath) // /xxx/:_1/:_2/:_3 ===> /xxx/aaa/:bbb/ccc
			}

			// return the accepted route
			return route.handlers, true
		}
	}

	// not found
	return nil, false
}
