package xgin

import (
	"fmt"
	"github.com/Aoi-hosizora/ahlib/xnumber"
	"github.com/Aoi-hosizora/ahlib/xreflect"
	"github.com/gin-gonic/gin"
	"net/http"
	"reflect"
	"runtime"
	"strings"
)

// AppRouter represents a group of routers with gin.Engine and gin.IRouter, is a replacement of gin's trie router model,
// see https://github.com/gin-gonic/gin/blob/master/tree.go.
//
// Note:
//
// 1. gin.Engine supports:
// 	router.GET(":a", fn)
// 	router.GET(":a/:b", fn)
//
// 2. gin.Engine does not support:
// 	router.GET("a", fn)
// 	router.GET(":a/:b", fn) // conflict, panic
//
// 3. xgin.AppRouter supports:
// 	ap.GET("a", fn)
// 	ap.GET(":a", fn)
// 	ap.GET(":a/b", fn)
// 	ap.GET(":a/:b", fn)
type AppRouter struct {
	engine *gin.Engine
	router gin.IRouter
	groups [][]*routerConfig // groups: []method, method: []*routerConfig.

	noRoute  gin.HandlersChain // for 404
	noMethod gin.HandlersChain // for 405
}

// NewAppRouter creates an empty AppRouter using given gin.Engine and gin.IRouter.
//
// Example:
// 	app := gin.New()
// 	v1 := app.Group("v1")
// 	ap := xgin.NewAppRouter(app, v1)
// 	ap.GET("a", fn)     // /v1/a
// 	ap.GET(":a", fn)    // /v1/:a
// 	ap.GET(":a/b", fn)  // /v1/:a/b
// 	ap.GET(":a/:b", fn) // /v1/:a/:b
// 	ap.Register()
func NewAppRouter(engine *gin.Engine, router gin.IRouter) *AppRouter {
	noRoute := xreflect.GetUnexportedField(reflect.ValueOf(engine).Elem().FieldByName("noRoute")).(gin.HandlersChain)
	noMethod := xreflect.GetUnexportedField(reflect.ValueOf(engine).Elem().FieldByName("noMethod")).(gin.HandlersChain)
	if noRoute == nil {
		noRoute = []gin.HandlerFunc{func(c *gin.Context) {
			c.String(404, "404 page not found") // default 404
		}}
	}
	if noMethod == nil {
		noMethod = []gin.HandlerFunc{func(c *gin.Context) {
			c.String(405, "405 method not allowed") // default 405
		}}
	}

	return &AppRouter{
		engine: engine, router: router, groups: [][]*routerConfig{},
		noRoute: noRoute, noMethod: noMethod,
	}
}

// routerConfig represents a router config used in AppRouter, including method, relativePath and handlers.
type routerConfig struct {
	method       string
	relativePath string
	handlers     []gin.HandlerFunc
	layerNames   []string // generated by relativePath
}

const (
	panicNoHandler        = "xgin: router must have at least one handler"
	panicUseUnderlineName = "xgin: router's layer name starts with '_'"
)

// newRouterConfig creates an instance of routerConfig, panics if handlers is empty.
func newRouterConfig(method string, relativePath string, handlers ...gin.HandlerFunc) *routerConfig {
	if len(handlers) == 0 {
		panic(panicNoHandler)
	}

	relativePath = strings.Trim(relativePath, "/")
	layerNames := make([]string, 0) // each layer's name
	if relativePath != "" {
		layerNames = strings.Split(relativePath, "/")
	}
	return &routerConfig{method: method, relativePath: relativePath, handlers: handlers, layerNames: layerNames}
}

// GET registers a new list of handlers to given path and uses get method.
func (a *AppRouter) GET(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodGet, relativePath, handlers)
}

// POST registers a new list of handlers to given path and uses post method.
func (a *AppRouter) POST(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodPost, relativePath, handlers)
}

// DELETE registers a new list of handlers to given path and uses delete method.
func (a *AppRouter) DELETE(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodDelete, relativePath, handlers)
}

// PATCH registers a new list of handlers to given path and uses patch method.
func (a *AppRouter) PATCH(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodPatch, relativePath, handlers)
}

// PUT registers a new list of handlers to given path and uses put method.
func (a *AppRouter) PUT(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodPut, relativePath, handlers)
}

// OPTIONS registers a new list of handlers to given path and uses options method.
func (a *AppRouter) OPTIONS(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodOptions, relativePath, handlers)
}

// HEAD registers a new list of handlers to given path and uses head method.
func (a *AppRouter) HEAD(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodHead, relativePath, handlers)
}

// Any registers a new list of handlers to given path and uses all the supported http methods: get, post, delete, patch, put, options, head.
func (a *AppRouter) Any(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodGet, relativePath, handlers)
	a.addToGroups(http.MethodPost, relativePath, handlers)
	a.addToGroups(http.MethodDelete, relativePath, handlers)
	a.addToGroups(http.MethodPatch, relativePath, handlers)
	a.addToGroups(http.MethodPut, relativePath, handlers)
	a.addToGroups(http.MethodOptions, relativePath, handlers)
	a.addToGroups(http.MethodHead, relativePath, handlers)
}

// addToGroups is used to add handlers to AppRouter.groups, panics when given IRouter has a `_` started layer name.
func (a *AppRouter) addToGroups(method, relativePath string, handlers []gin.HandlerFunc) {
	routerGroup := a.router.(*gin.RouterGroup) // IRouter must be a gin.RouterGroup
	basePath := xreflect.GetUnexportedField(reflect.ValueOf(routerGroup).Elem().FieldByName("basePath")).(string)
	for _, layerName := range strings.Split(basePath, "/") { // maybe incomplete basePath
		if strings.HasPrefix(layerName, "_") { // check `_xxx` layer name first
			panic(panicUseUnderlineName)
		}
	}

	r := newRouterConfig(method, relativePath, handlers...)
	for idx := range a.groups {
		routers := a.groups[idx] // same method's routers
		if routers[0].method == method {
			a.groups[idx] = append(routers, r)
			return
		}
	}
	a.groups = append(a.groups, []*routerConfig{r})
}

// Register registers all registered routers to gin.IRouter using gin.Engine's config.
func (a *AppRouter) Register() {
	for idx := range a.groups {
		routers := a.groups[idx] // same method's routers
		method := routers[0].method
		coreAppRouterRegister(a, method, routers) // register same method's all routers
	}
}

// DebugAppRouterPrintFunc is a logger function (do log after gin's each handler's log) for the same layer's handlers, it uses the given
// method, relativePath, handlerFuncname, handlersCount, layerFakePath, and the current router's index and total layer's count.
var DebugAppRouterPrintFunc = func(index, count int, method, relativePath, handlerFuncname string, handlersCount int, layerFakePath string) {
	pre := "├─"
	if index == count-1 {
		pre = "└─"
	}
	fmt.Printf("[XGIN]   %2s %-6s ~/%-23s --> %s (%d handlers) ==> ~/%s\n", pre, method, relativePath, handlerFuncname, handlersCount, layerFakePath)
	// [GIN-debug] POST   /v1/:_1/:_2/:_3           --> github.com/Aoi-hosizora/ahlib-web/xgin.buildAppRouterHandler.func1 (1 handlers)
	// [XGIN]   └─ POST   ~/a/b/:c                  --> github.com/Aoi-hosizora/ahlib-web/xgin.TestAppRouter.func17 (1 handlers) ==> ~/:_1/:_2/:_3
}

// ====
// core
// ====

// coreAppRouterRegister is the core implementation of AppRouter.Register, with given method and routers.
func coreAppRouterRegister(ar *AppRouter, method string, routers []*routerConfig) {
	// get max layer count
	maxLayerCount := 0
	for _, methodRouter := range routers {
		if len(methodRouter.layerNames) > maxLayerCount {
			maxLayerCount = len(methodRouter.layerNames)
		}
	}

	// rearrange routers by layer count
	layersRouters := make([][]*routerConfig, maxLayerCount+1) // 1dim: layers, 2dim: routers
	for _, methodRouter := range routers {
		layerCount := len(methodRouter.layerNames)
		layersRouters[layerCount] = append(layersRouters[layerCount], methodRouter)
	}

	// core: build handler to handle !!!
	for layer := range layersRouters {
		layerRouters := layersRouters[layer] // same layer's routers

		// empty relative path
		if layer == 0 {
			for _, router := range layerRouters { // only one
				ar.router.Handle(method, "", router.handlers...) // handle first
			}
			continue
		}

		// build layer fake path string
		layerNumericPaths := make([]string, layer) // :_1, :_2, ...
		for i := 1; i <= layer; i++ {
			layerNumericPaths[i-1] = ":_" + xnumber.Itoa(i)
		}
		layerFakePath := strings.Join(layerNumericPaths, "/") // :_1/:_2/...

		// get final handler and register to gin.IRouter
		targetHandler := buildAppRouterHandler(ar, method, layerRouters, layerFakePath)
		ar.router.Handle(method, layerFakePath, targetHandler)

		// do log after gin's log
		if gin.Mode() == gin.DebugMode && DebugAppRouterPrintFunc != nil {
			for i, router := range layerRouters { // same layer's routers
				funcname := runtime.FuncForPC(reflect.ValueOf(router.handlers[0]).Pointer()).Name()
				DebugAppRouterPrintFunc(i, len(layerRouters), method, router.relativePath, funcname, len(router.handlers), layerFakePath)
			}
		}
	}
}

// buildAppRouterHandler builds and returns a new gin.HandlerFunc for AppRouter to register to gin.IRouter using given layer routers.
func buildAppRouterHandler(ar *AppRouter, method string, layerRouters []*routerConfig, layerFakePath string) gin.HandlerFunc {
	// will be invoked at runtime
	return func(c *gin.Context) {
		// find accepted handlers ==> O(avg_#routers * avg_#layers)
		handlers, ok := findAppRouterHandlers(c, layerRouters, layerFakePath, true)

		// handlers not found, use 404 or 405 (note that this may be handled by gin)
		if !ok {
			handlers = ar.noRoute // use 404 noRoute
			if ar.engine.HandleMethodNotAllowed {
				for _, methodRouters := range ar.groups {
					if method == methodRouters[0].method {
						continue
					}
					if _, ok := findAppRouterHandlers(c, methodRouters, layerFakePath, false); ok {
						handlers = ar.noMethod // use 405 noMethod
						break
					}
				}
			}
		}

		// run handlers
		for _, handler := range handlers {
			if handler != nil && !c.IsAborted() {
				handler(c)
			}
		}
	}
}

// findAppRouterHandlers finds a acceptable []gin.HandlerFunc from routers by given gin.Context (with its parameters) and switcher for changing gin.Context's parameter.
func findAppRouterHandlers(c *gin.Context, routers []*routerConfig, layerFakePath string, changeContext bool) ([]gin.HandlerFunc, bool) {
	for _, router := range routers {
		// filter different length of path layers
		actualLayerCount := 0 // start with _'s layer name's count
		for _, param := range c.Params {
			if strings.HasPrefix(param.Key, "_") {
				actualLayerCount++
			}
		}
		if actualLayerCount != len(router.layerNames) {
			continue
		}

		// check if accept the current router
		accept := true
		for idx, layerName := range router.layerNames {
			// layerNames: aaa, :bbb, ccc
			// fullPath: /xxx/:_1/:_2/:_3
			if strings.HasPrefix(layerName, ":") { // start with `:`, is a parameter, need to be converted
				continue
			}
			layerKey := "_" + xnumber.Itoa(idx+1)
			if layerName != c.Param(layerKey) {
				accept = false // the actual layer name does not equal to the given router's layer name
				break
			}
		}

		// change context and return if accept
		if accept {
			if changeContext {
				// set new c.Params
				for idx, layerName := range router.layerNames {
					if strings.HasPrefix(layerName, ":") { // is a parameter
						key := layerName[1:]                  // :bbb ===> :_2
						layerKey := "_" + xnumber.Itoa(idx+1) // :_2
						value := c.Param(layerKey)
						c.Params = append(c.Params, gin.Param{Key: key, Value: value})
					}
				}

				// set new c.fullPath
				fullPath := strings.TrimSuffix(c.FullPath(), "/")
				fullPath = strings.TrimSuffix(strings.TrimSuffix(fullPath, layerFakePath), "/")
				fullPath = fmt.Sprintf("%s/%s", fullPath, router.relativePath)
				xreflect.SetUnexportedField(reflect.ValueOf(c).Elem().FieldByName("fullPath"), fullPath) // /xxx/:_1/:_2/:_3 ===> /xxx/aaa/:bbb/ccc
			}

			// return the accepted router
			return router.handlers, true
		}
	}

	// not found
	return nil, false
}
