package xgin

import (
	"fmt"
	"github.com/Aoi-hosizora/ahlib/xnumber"
	"github.com/Aoi-hosizora/ahlib/xreflect"
	"github.com/gin-gonic/gin"
	"net/http"
	"reflect"
	"runtime"
	"strings"
)

// AppRouter represents a group of routers with gin.Engine and gin.IRouter, is a replacement of gin's trie router model,
// see https://github.com/gin-gonic/gin/blob/master/tree.go.
//
// Note:
//
// 1. gin.Engine supports:
// 	router.GET(":a", fn)
// 	router.GET(":a/b", fn)
//
// 2. gin.Engine does not support: (contains "x" and ":x" in the same layer)
// 	router.GET(":a", fn)
// 	router.GET("a", fn) // 'a' in new path '/a' conflicts with existing wildcard ':a' in existing prefix '/:a'
// 	// and
// 	router.GET(":a/b", fn)
// 	router.GET("a", fn) // 'a' in new path '/a' conflicts with existing wildcard ':a' in existing prefix '/:a'
// 	// and
// 	router.GET(":a/:b", fn)
// 	router.GET(":a/b", fn) // 'b' in new path '/:a/b' conflicts with existing wildcard ':b' in existing prefix '/:a/:b'
// 	// and
// 	router.GET(":a", fn)
// 	router.GET(":b", fn) // ':b' in new path '/:b' conflicts with existing wildcard ':a' in existing prefix '/:a'
//
// 3. xgin.AppRouter supports:
// 	ap.GET(":a", fn)
// 	ap.GET("a", fn)
// 	ap.GET(":a/:b", fn)
// 	ap.GET(":a/b", fn)
//
// 4. xgin.AppRouter does not support:
// 	ap.GET(":a", fn)
// 	ap.GET(":b", fn) // X
type AppRouter struct {
	engine *gin.Engine
	router gin.IRouter
	groups [][]*routerConfig // groups: []method, method: []*routerConfig.

	noRouter gin.HandlersChain // for 404
	noMethod gin.HandlersChain // for 405
}

// NewAppRouter creates an empty AppRouter using given gin.Engine and gin.IRouter.
//
// Example:
// 	app := gin.New()
// 	v1 := app.Group("v1")
// 	ap := xgin.NewAppRouter(app, v1)
// 	ap.GET("a", fn)     // /v1/a
// 	ap.GET(":a", fn)    // /v1/:a
// 	ap.GET(":a/b", fn)  // /v1/:a/b
// 	ap.GET(":a/:b", fn) // /v1/:a/:b
// 	ap.Register()
func NewAppRouter(engine *gin.Engine, router gin.IRouter) *AppRouter {
	noRouter := xreflect.GetUnexportedField(reflect.ValueOf(engine).Elem().FieldByName("noRoute")).(gin.HandlersChain)
	noMethod := xreflect.GetUnexportedField(reflect.ValueOf(engine).Elem().FieldByName("noMethod")).(gin.HandlersChain)
	if noRouter == nil {
		noRouter = []gin.HandlerFunc{func(c *gin.Context) {
			c.String(404, "404 page not found") // default 404
		}}
	}
	if noMethod == nil {
		noMethod = []gin.HandlerFunc{func(c *gin.Context) {
			c.String(405, "405 method not allowed") // default 405
		}}
	}
	noRouter = append([]gin.HandlerFunc{func(c *gin.Context) {
		xreflect.SetUnexportedField(reflect.ValueOf(c).Elem().FieldByName("fullPath"), "")
	}}, noRouter...)
	noMethod = append([]gin.HandlerFunc{func(c *gin.Context) {
		xreflect.SetUnexportedField(reflect.ValueOf(c).Elem().FieldByName("fullPath"), "")
	}}, noMethod...)

	return &AppRouter{
		engine: engine, router: router, groups: [][]*routerConfig{},
		noRouter: noRouter, noMethod: noMethod,
	}
}

// routerConfig represents a router config used in AppRouter, including method, relativePath and handlers.
type routerConfig struct {
	method       string
	relativePath string
	handlers     []gin.HandlerFunc
	layerNames   []string // generated by relativePath
}

// GET registers a new list of handlers to given path and uses get method.
func (a *AppRouter) GET(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodGet, relativePath, handlers)
}

// POST registers a new list of handlers to given path and uses post method.
func (a *AppRouter) POST(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodPost, relativePath, handlers)
}

// DELETE registers a new list of handlers to given path and uses delete method.
func (a *AppRouter) DELETE(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodDelete, relativePath, handlers)
}

// PATCH registers a new list of handlers to given path and uses patch method.
func (a *AppRouter) PATCH(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodPatch, relativePath, handlers)
}

// PUT registers a new list of handlers to given path and uses put method.
func (a *AppRouter) PUT(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodPut, relativePath, handlers)
}

// OPTIONS registers a new list of handlers to given path and uses options method.
func (a *AppRouter) OPTIONS(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodOptions, relativePath, handlers)
}

// HEAD registers a new list of handlers to given path and uses head method.
func (a *AppRouter) HEAD(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodHead, relativePath, handlers)
}

// Any registers a new list of handlers to given path and uses all the supported http methods: get, post, delete, patch, put, options, head.
func (a *AppRouter) Any(relativePath string, handlers ...gin.HandlerFunc) {
	a.addToGroups(http.MethodGet, relativePath, handlers)
	a.addToGroups(http.MethodPost, relativePath, handlers)
	a.addToGroups(http.MethodDelete, relativePath, handlers)
	a.addToGroups(http.MethodPatch, relativePath, handlers)
	a.addToGroups(http.MethodPut, relativePath, handlers)
	a.addToGroups(http.MethodOptions, relativePath, handlers)
	a.addToGroups(http.MethodHead, relativePath, handlers)
}

const (
	panicNoHandler         = "xgin: router must have at least one handler"
	panicAlreadyRegistered = "xgin: handlers are already registered for path '/%s' in existing path '/%s'"
)

// newRouterConfig creates an instance of routerConfig, panics if handlers is empty.
func newRouterConfig(method string, relativePath string, handlers ...gin.HandlerFunc) *routerConfig {
	if len(handlers) == 0 {
		panic(panicNoHandler)
	}

	relativePath = strings.Trim(relativePath, "/")
	layerNames := make([]string, 0) // each layer's name
	if relativePath != "" {
		layerNames = strings.Split(relativePath, "/")
	}
	return &routerConfig{method: method, relativePath: relativePath, handlers: handlers, layerNames: layerNames}
}

// addToGroups is used to add handlers to AppRouter.groups, note that this method does no check for "_$" prefix router, panics when router paths are conflict.
func (a *AppRouter) addToGroups(method, relativePath string, handlers []gin.HandlerFunc) {
	r := newRouterConfig(method, relativePath, handlers...)
	for idx := range a.groups {
		routers := a.groups[idx] // same method's routers
		if routers[0].method != r.method {
			continue
		}

		// check conflict
		for _, router := range routers {
			if len(router.layerNames) != len(r.layerNames) {
				continue
			}

			// same layers count
			diff := false
			for i := range r.layerNames {
				if !strings.HasPrefix(r.layerNames[i], ":") || !strings.HasPrefix(router.layerNames[i], ":") {
					diff = true // one of the layers is not parametered
					break
				}
			}
			if !diff {
				panic(fmt.Sprintf(panicAlreadyRegistered, r.relativePath, router.relativePath))
			}
		}

		// append router
		a.groups[idx] = append(routers, r)
		return
	}

	// append method
	a.groups = append(a.groups, []*routerConfig{r})
}

// Register registers all registered routers to gin.IRouter using gin.Engine's config.
func (a *AppRouter) Register() {
	for idx := range a.groups {
		routers := a.groups[idx] // same method's routers
		method := routers[0].method
		coreAppRouterRegister(a, method, routers) // register same method's all routers
	}
}

// PrintAppRouterRegisterFunc is a logger function for AppRouter.Register, logs after gin's [GIN-debug] logger.
var PrintAppRouterRegisterFunc func(index, count int, method, relativePath, handlerFuncname string, handlersCount int, layerFakePath string)

// printAppRouteRegister represents the inner logger function for AppRouter.Register, used in coreAppRouterRegister.
// Logs like:
// 	[GIN-debug] GET    /v1/:_$1/:_$2             --> github.com/Aoi-hosizora/ahlib-web/xgin.buildAppRouterHandler.func1 (1 handlers)
// 	[XGIN]   ├─ GET    ~/a/b                     --> github.com/Aoi-hosizora/ahlib-web/xgin.TestAppRouter.func3 (1 handlers) ==> ~/:_$1/:_$2
// 	[XGIN]   ├─ GET    ~/a/:y                    --> github.com/Aoi-hosizora/ahlib-web/xgin.TestAppRouter.func3 (1 handlers) ==> ~/:_$1/:_$2
// 	[XGIN]   ├─ GET    ~/:x/b                    --> github.com/Aoi-hosizora/ahlib-web/xgin.TestAppRouter.func3 (1 handlers) ==> ~/:_$1/:_$2
// 	[XGIN]   └─ GET    ~/:x/:y                   --> github.com/Aoi-hosizora/ahlib-web/xgin.TestAppRouter.func3 (1 handlers) ==> ~/:_$1/:_$2
// 	        |--|------|------------------------|
// 	         2    6               25
func printAppRouteRegister(index, count int, method, relativePath, handlerFuncname string, handlersCount int, layerFakePath string) {
	if PrintAppRouterRegisterFunc != nil {
		PrintAppRouterRegisterFunc(index, count, method, relativePath, handlerFuncname, handlersCount, layerFakePath)
		return
	}

	pre := "├─"
	if index == count-1 {
		pre = "└─"
	}
	fmt.Printf("[XGIN]   %2s %-6s ~/%-23s --> %s (%d handlers) ==> ~/%s\n", pre, method, relativePath, handlerFuncname, handlersCount, layerFakePath)
}

// ====
// core
// ====

const (
	_fakePathPrefix = "_$"
)

// coreAppRouterRegister is the core implementation of AppRouter.Register, with given method and routers.
func coreAppRouterRegister(ar *AppRouter, method string, routers []*routerConfig) {
	// get max layer count
	maxLayerCount := 0
	for _, methodRouter := range routers {
		if len(methodRouter.layerNames) > maxLayerCount {
			maxLayerCount = len(methodRouter.layerNames)
		}
	}

	// rearrange routers by layer count
	layersRouters := make([][]*routerConfig, maxLayerCount+1) // 1dim: layers, 2dim: routers
	for _, methodRouter := range routers {
		layerCount := len(methodRouter.layerNames)
		layersRouters[layerCount] = append(layersRouters[layerCount], methodRouter)
	}

	// core: build handler to handle !!!
	for layer := range layersRouters {
		layerRouters := layersRouters[layer] // same layer's routers

		// empty relative path
		if layer == 0 {
			for _, router := range layerRouters { // only one
				ar.router.Handle(method, "", router.handlers...) // handle first
			}
			continue
		}

		// build layer fake path string
		layerNumericPaths := make([]string, layer) // :_$1, :_$2, ...
		for i := 1; i <= layer; i++ {
			layerNumericPaths[i-1] = ":" + _fakePathPrefix + xnumber.Itoa(i) // <<< :_$
		}
		layerFakePath := strings.Join(layerNumericPaths, "/") // :_$1/:_$2/...

		// get final handler and register to gin.IRouter
		targetHandler := buildAppRouterHandler(ar, method, layerRouters, layerFakePath)
		ar.router.Handle(method, layerFakePath, targetHandler)

		// do log after gin's log
		if gin.Mode() == gin.DebugMode {
			for i, router := range layerRouters { // same layer's routers
				funcname := runtime.FuncForPC(reflect.ValueOf(router.handlers[0]).Pointer()).Name()
				printAppRouteRegister(i, len(layerRouters), method, router.relativePath, funcname, len(router.handlers), layerFakePath)
			}
		}
	}
}

// buildAppRouterHandler builds and returns a new gin.HandlerFunc for AppRouter to register to gin.IRouter using given layer routers.
func buildAppRouterHandler(ar *AppRouter, method string, layerRouters []*routerConfig, layerFakePath string) gin.HandlerFunc {
	// will be invoked at runtime
	return func(c *gin.Context) {
		// find accepted handlers ==> O(avg_#routers * avg_#layers)
		handlers, ok := findAppRouterHandlers(c, layerRouters, layerFakePath, true)

		// handlers not found, use 404 or 405 (note that this may be handled by gin)
		if !ok {
			handlers = ar.noRouter // use 404 noRouter
			if ar.engine.HandleMethodNotAllowed {
				for _, methodRouters := range ar.groups {
					if method == methodRouters[0].method {
						continue
					}
					if _, ok := findAppRouterHandlers(c, methodRouters, layerFakePath, false); ok {
						handlers = ar.noMethod // use 405 noMethod
						break
					}
				}
			}
		}

		// run handlers
		for _, handler := range handlers {
			if handler != nil && !c.IsAborted() {
				handler(c)
			}
		}
	}
}

// findAppRouterHandlers finds a acceptable []gin.HandlerFunc from routers by given gin.Context (with its parameters) and switcher for changing gin.Context's parameter.
func findAppRouterHandlers(c *gin.Context, routers []*routerConfig, layerFakePath string, changeContext bool) ([]gin.HandlerFunc, bool) {
	for _, router := range routers {
		// filter different length of path layers
		actualLayerCount := 0 // start with _$'s layer name's count
		for _, param := range c.Params {
			if strings.HasPrefix(param.Key, _fakePathPrefix) {
				actualLayerCount++
			}
		}
		if actualLayerCount != len(router.layerNames) {
			continue
		}

		// check if accept the current router
		accept := true
		for idx, layerName := range router.layerNames {
			// layerNames: aaa, :bbb, ccc
			// fullPath: /xxx/:_$1/:_$2/:_$3
			if strings.HasPrefix(layerName, ":") { // start with `:`, is a parameter, need to be converted
				continue
			}
			layerKey := _fakePathPrefix + xnumber.Itoa(idx+1)
			if layerName != c.Param(layerKey) {
				accept = false // the actual layer name does not equal to the given router's layer name
				break
			}
		}

		// change context and return if accept
		if accept {
			if changeContext {
				// set new c.Params
				for idx, layerName := range router.layerNames {
					if strings.HasPrefix(layerName, ":") { // is a parameter
						key := layerName[1:]                              // :bbb ===> :_$2
						layerKey := _fakePathPrefix + xnumber.Itoa(idx+1) // :_$2
						value := c.Param(layerKey)
						c.Params = append(c.Params, gin.Param{Key: key, Value: value})
					}
				}

				// set new c.fullPath
				fullPath := strings.TrimSuffix(c.FullPath(), "/")
				fullPath = strings.TrimSuffix(strings.TrimSuffix(fullPath, layerFakePath), "/")
				fullPath = fmt.Sprintf("%s/%s", fullPath, router.relativePath)
				xreflect.SetUnexportedField(reflect.ValueOf(c).Elem().FieldByName("fullPath"), fullPath) // /xxx/:_$1/:_$2/:_$3 ===> /xxx/aaa/:bbb/ccc
			}

			// return the accepted router
			return router.handlers, true
		}
	}

	// not found
	return nil, false
}
